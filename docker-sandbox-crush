#!/bin/bash

set -e

print_usage() {
    echo "Usage: docker-sandbox-crush <command>"
    echo ""
    echo "Commands:"
    echo "  run     Run Crush CLI in Docker sandbox"
    echo "  clean   Remove the sandbox container for current workspace"
    echo ""
    echo "Options:"
    echo "  --force  Skip confirmation for clean command"
}

validate_docker() {
    # Check if Docker CLI is installed
    if ! command -v docker &> /dev/null; then
        echo "Error: docker CLI is not installed or not in PATH" >&2
        return 1
    fi

    # Check if Docker daemon is running and accessible
    if ! docker info &> /dev/null; then
        echo "Error: docker daemon is not running or not accessible" >&2
        return 1
    fi

    return 0
}

get_workspace_info() {
    local workspace
    workspace="$(pwd)"
    echo "$workspace"
}

read_git_config() {
    local gitconfig="$HOME/.gitconfig"
    local user_name=""
    local user_email=""

    if [ -f "$gitconfig" ]; then
        user_name="$(git config --file "$gitconfig" user.name 2>/dev/null || echo "")"
        user_email="$(git config --file "$gitconfig" user.email 2>/dev/null || echo "")"
    else
        echo "Warning: ~/.gitconfig not found" >&2
    fi

    if [ -z "$user_name" ] && [ -z "$user_email" ]; then
        echo "Warning: Git user.name and user.email not configured" >&2
    fi

    echo "$user_name|$user_email"
}

get_container_name() {
    local workspace="$1"
    # Use md5 hash of workspace path for deterministic container name
    # Prefix with 'crush-sandbox-' for readability
    local hash
    hash="$(echo -n "$workspace" | md5)"
    echo "crush-sandbox-${hash}"
}

get_cache_volume_name() {
    local workspace="$1"
    # Use md5 hash of workspace path for deterministic volume name
    # Prefix with 'crush-cache-' for readability
    local hash
    hash="$(echo -n "$workspace" | md5)"
    echo "crush-cache-${hash}"
}

container_exists() {
    local container_name="$1"
    # Use docker ps -a to check if container exists (including stopped containers)
    # --filter name=... matches containers with the exact name
    docker ps -a --filter "name=^${container_name}$" --format '{{.Names}}' | grep -q "^${container_name}$"
    return $?
}

create_cache_volume() {
    local cache_volume_name="$1"

    # Check if volume already exists
    if docker volume ls -q --filter "name=^${cache_volume_name}$" | grep -q "^${cache_volume_name}$"; then
        echo "Using existing cache volume: $cache_volume_name"
        return 0
    fi

    # Create the volume
    echo "Creating cache volume: $cache_volume_name"
    docker volume create "$cache_volume_name" > /dev/null
    echo "Cache volume created: $cache_volume_name"
}

create_container() {
    local workspace="$1"
    local container_name="$2"
    local git_name="$3"
    local git_email="$4"
    local cache_volume_name="$5"

    local base_image="node:18-alpine"
    local docker_args=(
        "--name" "$container_name"
        "-v" "${workspace}:${workspace}"
        "-v" "${cache_volume_name}:/workspace-cache"
        "-w" "$workspace"
    )

    # Configure npm cache to use persistent volume
    docker_args+=("-e" "npm_config_cache=/workspace-cache/npm")

    # Add environment variables for Git config if available
    if [ -n "$git_name" ]; then
        docker_args+=("-e" "GIT_USER_NAME=${git_name}")
    fi
    if [ -n "$git_email" ]; then
        docker_args+=("-e" "GIT_USER_EMAIL=${git_email}")
    fi

    docker_args+=("$base_image")
    # Use tail -f /dev/null to keep container running
    docker_args+=("tail" "-f" "/dev/null")

    echo "Creating container from image: ${base_image}"
    docker create "${docker_args[@]}"
}

run_container() {
    local container_name="$1"

    # Start the container (or restart if it was stopped)
    echo "Starting container..."
    docker start "$container_name" > /dev/null

    # Execute an interactive shell in the container
    # This allows the user to run Crush CLI commands
    echo "Starting interactive shell in sandbox..."
    if [ -t 0 ]; then
        # Interactive mode with TTY
        docker exec -it "$container_name" /bin/sh
    else
        # Non-interactive mode (for testing)
        echo "Warning: Not running in TTY mode, starting shell anyway..."
        docker exec -i "$container_name" /bin/sh
    fi

    # Stop the container after the session ends (but don't remove it)
    echo "Stopping container..."
    docker stop "$container_name" > /dev/null
    echo "Container stopped"
}

run_command() {
    # Validate Docker is available
    if ! validate_docker; then
        exit 1
    fi

    # Get workspace info
    local workspace
    workspace="$(get_workspace_info)"
    echo "Workspace: $workspace"

    # Get container name
    local container_name
    container_name="$(get_container_name "$workspace")"
    echo "Container name: $container_name"

    # Get cache volume name
    local cache_volume_name
    cache_volume_name="$(get_cache_volume_name "$workspace")"
    echo "Cache volume: $cache_volume_name"

    # Create cache volume if it doesn't exist
    create_cache_volume "$cache_volume_name"

    # Read Git config
    local git_config
    git_config="$(read_git_config)"
    local git_name="${git_config%|*}"
    local git_email="${git_config##*|}"

    if [ -n "$git_name" ]; then
        echo "Git user.name: $git_name"
    fi
    if [ -n "$git_email" ]; then
        echo "Git user.email: $git_email"
    fi

    # Check if container exists, create if not
    if container_exists "$container_name"; then
        echo "Reusing existing container"
    else
        echo "Creating new container"
        create_container "$workspace" "$container_name" "$git_name" "$git_email" "$cache_volume_name"
    fi

    # Run the container
    run_container "$container_name"
}

clean_command() {
    local force="$1"

    # Validate Docker is available
    if ! validate_docker; then
        exit 1
    fi

    # Get workspace info
    local workspace
    workspace="$(get_workspace_info)"

    # Get container name
    local container_name
    container_name="$(get_container_name "$workspace")"

    # Check if container exists
    if ! container_exists "$container_name"; then
        echo "No sandbox container found for workspace: $workspace"
        exit 0
    fi

    echo "Found container: $container_name"

    # Confirm deletion unless --force flag is set
    if [ "$force" != "true" ]; then
        read -p "Are you sure you want to remove the container '$container_name'? [y/N] " confirm
        if [[ ! "$confirm" =~ ^[yY] ]]; then
            echo "Aborted"
            exit 0
        fi
    fi

    # Stop the container if it's running
    echo "Stopping container..."
    docker stop "$container_name" > /dev/null 2>&1 || true

    # Remove the container
    echo "Removing container..."
    docker rm "$container_name" > /dev/null 2>&1 || true

    echo "Container removed: $container_name"
}

# Main script logic
if [ $# -lt 1 ]; then
    print_usage >&2
    exit 1
fi

# Parse arguments
COMMAND=""
FORCE="false"

for arg in "$@"; do
    if [ "$arg" = "--force" ]; then
        FORCE="true"
    elif [ -z "$COMMAND" ]; then
        COMMAND="$arg"
    fi
done

if [ -z "$COMMAND" ]; then
    print_usage >&2
    exit 1
fi

case "$COMMAND" in
    run)
        run_command
        ;;
    clean|reset)
        clean_command "$FORCE"
        ;;
    *)
        echo "Error: Unknown command: $COMMAND" >&2
        print_usage >&2
        exit 1
        ;;
esac
