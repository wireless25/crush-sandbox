#!/bin/bash

set -e

VERSION="0.5.1"

# Docker image configuration - can be overridden via DOCKER_SANDBOX_IMAGE environment variable
DOCKER_IMAGE="${DOCKER_SANDBOX_IMAGE:-node:22-alpine}"

print_usage() {
    echo "Usage: crush-sandbox <command> [options]"
    echo ""
    echo "Commands:"
    echo "  run           Run Crush CLI in Docker sandbox"
    echo "  clean         Remove the sandbox container for current workspace"
    echo "  install       Install this script to /usr/local/bin"
    echo "  update        Update to the latest version"
    echo ""
    echo "Options:"
    echo "  --version          Show version information"
    echo "  --force            Skip confirmation for clean command"
    echo "  --shell            Start interactive shell instead of Crush CLI (for debugging)"
    echo "  --no-host-config    Skip mounting host Crush config directory"
    echo "  --cred-scan        Enable credential scanning before starting container"
}

validate_docker() {
    # Check if Docker CLI is installed
    if ! command -v docker &> /dev/null; then
        echo "Error: docker CLI is not installed or not in PATH" >&2
        return 1
    fi

    # Check if Docker daemon is running and accessible
    if ! docker info &> /dev/null; then
        echo "Error: docker daemon is not running or not accessible" >&2
        return 1
    fi

    return 0
}

validate_workspace_path() {
    local workspace="$1"

    # Check for problematic shell metacharacters that could cause command injection
    # Use grep for reliable pattern matching

    # Check for dollar sign
    if echo "$workspace" | grep -q '\$'; then
        echo "Error: Workspace path contains invalid character '\$': $workspace" >&2
        exit 1
    fi

    # Check for backtick
    if echo "$workspace" | grep -q '\`'; then
        echo "Error: Workspace path contains invalid character 'backtick': $workspace" >&2
        exit 1
    fi

    # Check for backslash
    if echo "$workspace" | grep -q '\\'; then
        echo "Error: Workspace path contains invalid character 'backslash': $workspace" >&2
        exit 1
    fi

    # Check for semicolon
    if echo "$workspace" | grep -q ';'; then
        echo "Error: Workspace path contains invalid character ';': $workspace" >&2
        exit 1
    fi

    # Check for pipe
    if echo "$workspace" | grep -q '|'; then
        echo "Error: Workspace path contains invalid character '|': $workspace" >&2
        exit 1
    fi

    # Check for ampersand
    if echo "$workspace" | grep -q '&'; then
        echo "Error: Workspace path contains invalid character '&': $workspace" >&2
        exit 1
    fi

    # Check for less than
    if echo "$workspace" | grep -q '<'; then
        echo "Error: Workspace path contains invalid character '<': $workspace" >&2
        exit 1
    fi

    # Check for greater than
    if echo "$workspace" | grep -q '>'; then
        echo "Error: Workspace path contains invalid character '>': $workspace" >&2
        exit 1
    fi

    # Check for command substitution pattern $(...)
    if echo "$workspace" | grep -q '\$('; then
        echo "Error: Workspace path contains command substitution pattern: $workspace" >&2
        exit 1
    fi

    return 0
}

get_workspace_info() {
    local workspace
    workspace="$(pwd)"
    echo "$workspace"
}

read_git_config() {
    local gitconfig="$HOME/.gitconfig"
    local user_name=""
    local user_email=""

    if [ -f "$gitconfig" ]; then
        user_name="$(git config --file "$gitconfig" user.name 2>/dev/null || echo "")"
        user_email="$(git config --file "$gitconfig" user.email 2>/dev/null || echo "")"
    else
        echo "Warning: ~/.gitconfig not found" >&2
    fi

    if [ -z "$user_name" ] && [ -z "$user_email" ]; then
        echo "Warning: Git user.name and user.email not configured" >&2
    fi

    echo "$user_name|$user_email"
}

get_host_crush_config_path() {
    local config_path=""

    # Check ~/.config/crush/ first
    local config_dir_1="$HOME/.config/crush"
    if [ -d "$config_dir_1" ]; then
        if [ -r "$config_dir_1" ]; then
            config_path="$config_dir_1"
        else
            echo "Error: Crush config directory exists but is not readable: $config_dir_1" >&2
            exit 1
        fi
    fi

    # Log warning if no config directory found (but continue execution)
    if [ -z "$config_path" ]; then
        echo "Warning: No host Crush config directory found (checked ~/.config/crush/)" >&2
    fi

    echo "$config_path"
}


ensure_gitleaks_image() {
    local gitleaks_image="ghcr.io/gitleaks/gitleaks:latest"

    # Check if gitleaks image exists locally (fast path)
    if docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "^${gitleaks_image}$"; then
        return 0
    fi

    echo "Pulling gitleaks Docker image for credential scanning..."
    if docker pull "$gitleaks_image" > /dev/null 2>&1; then
        echo "✓ gitleaks Docker image pulled successfully"
        return 0
    else
        echo "Warning: Failed to pull gitleaks Docker image" >&2
        echo "  Credential scanning will be unavailable" >&2
        return 1
    fi
}

scan_credentials() {
    local workspace="$1"
    local enable_scan="$2"
    local gitleaks_image="ghcr.io/gitleaks/gitleaks:latest"

    # Skip scanning unless explicitly enabled
    if [ "$enable_scan" != "true" ]; then
        return 0
    fi

    # Ensure gitleaks image is available
    ensure_gitleaks_image

    # Check if gitleaks image exists locally (may have failed to pull)
    if ! docker images --format '{{.Repository}}:{{.Tag}}' | grep -q "^${gitleaks_image}$"; then
        echo "Warning: gitleaks Docker image not available - credential scanning skipped" >&2
        return 0
    fi

    echo "Scanning workspace for credentials..."

    # Run gitleaks scan using Docker image
    local scan_output
    local exit_code
    
    # Capture output and exit code with verbose error handling
    echo "Running: docker run --rm -v \"${workspace}:/path\" \"$gitleaks_image\" directory /path --no-banner" >&2
    
    # Temporarily disable 'set -e' to capture exit code without script termination
    set +e
    scan_output=$(docker run --rm -v "${workspace}:/path" "$gitleaks_image" directory /path --no-banner 2>&1)
    exit_code=$?
    set -e
    
    echo "Gitleaks exit code: $exit_code" >&2
    if [ -n "$scan_output" ]; then
        echo "Gitleaks output:" >&2
        echo "$scan_output" >&2
    fi

    if [ $exit_code -eq 0 ]; then
        echo "✓ No credentials detected"
    elif [ $exit_code -eq 1 ]; then
        echo "⚠️  WARNING: Potential credentials detected in workspace!"
        echo ""
        echo "⚠️  WARNING: Potential credentials detected in workspace!"
        echo ""
        echo "Found files that may contain secrets or credentials."
        echo "For your security, please:"
        echo "  1. Review and remove any API keys, passwords, or tokens"
        echo "  2. Add sensitive files to .gitignore"
        echo "  3. Rotate any exposed credentials"
        echo ""
        echo ""

        # Prompt user to continue or abort
        read -p "Continue anyway? [y/N] " confirm
        if [[ ! "$confirm" =~ ^[yY] ]]; then
            echo "Aborted"
            exit 0
        fi
        echo "Proceeding with credential warning..."
    else
        echo "ERROR: Something went wrong during credential scan."
        echo "$scan_output"
    fi

    return 0
}
get_container_name() {
    local workspace="$1"
    # Use SHA256 hash of workspace path for deterministic container name
    # Truncated to first 12 characters for reasonable length
    # Prefix with 'crush-sandbox-' for readability
    local hash
    hash="$(echo -n "$workspace" | shasum -a 256 | awk '{print $1}' | cut -c1-12)"
    echo "crush-sandbox-${hash}"
}

get_cache_volume_name() {
    local workspace="$1"
    # Use SHA256 hash of workspace path for deterministic volume name
    # Truncated to first 12 characters for reasonable length
    # Prefix with 'crush-cache-' for readability
    local hash
    hash="$(echo -n "$workspace" | shasum -a 256 | awk '{print $1}' | cut -c1-12)"
    echo "crush-cache-${hash}"
}

container_exists() {
    local container_name="$1"
    # Use docker ps -a to check if container exists (including stopped containers)
    # --filter name=... matches containers with the exact name
    docker ps -a --filter "name=^${container_name}$" --format '{{.Names}}' | grep -q "^${container_name}$"
    return $?
}

create_cache_volume() {
    local cache_volume_name="$1"

    # Check if volume already exists
    if docker volume ls -q --filter "name=^${cache_volume_name}$" | grep -q "^${cache_volume_name}$"; then
        echo "Using existing cache volume: $cache_volume_name"
        return 0
    fi

    # Create the volume
    echo "Creating cache volume: $cache_volume_name"
    docker volume create "$cache_volume_name" > /dev/null

    # Fix permissions for node user (UID 1000) so it can write to the cache
    docker run --rm -v "${cache_volume_name}:/workspace-cache" "${DOCKER_IMAGE}" chown -R 1000:1000 /workspace-cache > /dev/null 2>&1 || true

    echo "Cache volume created: $cache_volume_name"
}

create_container() {
    local workspace="$1"
    local container_name="$2"
    local git_name="$3"
    local git_email="$4"
    local cache_volume_name="$5"
    local host_config_path="$6"

    local base_image="${DOCKER_IMAGE}"
    local docker_args=(
        "--name" "$container_name"
        "-v" "${workspace}:${workspace}"
        "-v" "${cache_volume_name}:/workspace-cache"
        "-w" "$workspace"
        "--user" "1000:1000"
        "--memory=4g"
        "--memory-swap=4g"
        "--cpus=2.0"
        "--ulimit" "nproc=100"
        # Security: Drop all capabilities, then add back only what's needed
        "--cap-drop" "ALL"
        "--cap-add" "CHOWN"
        "--cap-add" "DAC_OVERRIDE"
    )

    # Mount host Crush config read-only if available
    if [ -n "$host_config_path" ]; then
        docker_args+=("-v" "${host_config_path}:/host-crush-config:ro")
    fi

    # Configure npm cache to use persistent volume
    docker_args+=("-e" "npm_config_cache=/workspace-cache/npm")

    # Add environment variables for Git config if available
    if [ -n "$git_name" ]; then
        docker_args+=("-e" "GIT_USER_NAME=${git_name}")
    fi
    if [ -n "$git_email" ]; then
        docker_args+=("-e" "GIT_USER_EMAIL=${git_email}")
    fi

    docker_args+=("$base_image")
    # Use tail -f /dev/null to keep container running
    docker_args+=("tail" "-f" "/dev/null")

    echo "Creating container from image: ${base_image}"
    docker create "${docker_args[@]}"
}

setup_crush_script() {
    local container_name="$1"

    # Create the setup script inside the container in /home/node/ where node user has write access
    docker exec "$container_name" sh -c 'cat > /home/node/setup-crush.sh << ENDSCRIPT
#!/bin/sh

# Configure npm to use node user home directory
mkdir -p /home/node/.npm-global
npm config set prefix /home/node/.npm-global

# Add npm global bin to PATH for this script session
export PATH=/home/node/.npm-global/bin:\$PATH

# Check if Crush CLI is already installed
if command -v crush >/dev/null 2>&1; then
    echo "Crush CLI is already installed"
    exit 0
fi

# Install Crush CLI via npm global install
echo "Installing Crush CLI..."
if npm install -g @charmland/crush >/dev/null 2>&1; then
    echo "Crush CLI installed successfully"
    exit 0
else
    echo "Error: Failed to install Crush CLI"
    exit 1
fi
ENDSCRIPT' >/dev/null 2>&1

    # Make the script executable
    docker exec "$container_name" chmod +x /home/node/setup-crush.sh >/dev/null 2>&1
}

setup_crush_config_script() {
    local container_name="$1"

    # Create the config merge script inside the container in /home/node/
    docker exec "$container_name" sh -c 'cat > /home/node/setup-crush-config.sh << ENDSCRIPT
#!/bin/sh

# Create merged config directory
mkdir -p /tmp/crush-config/merged

# Copy host config if available
if [ -d /host-crush-config ]; then
    cp -r /host-crush-config/* /tmp/crush-config/merged/ 2>/dev/null || true
    echo "Merged host configuration from /host-crush-config"
fi

# Set CRUSH_GLOBAL_CONFIG environment variable
export CRUSH_GLOBAL_CONFIG=/tmp/crush-config/merged
echo "Configuration merged to: \$CRUSH_GLOBAL_CONFIG"
ENDSCRIPT' >/dev/null 2>&1

    # Make the script executable
    docker exec "$container_name" chmod +x /home/node/setup-crush-config.sh >/dev/null 2>&1
}

run_container() {
    local container_name="$1"
    local shell_mode="$2"
    local host_config_path="$3"

    # Start the container (or restart if it was stopped)
    echo "Starting container..."
    docker start "$container_name" > /dev/null

    # Setup Crush CLI script
    setup_crush_script "$container_name"
    setup_crush_config_script "$container_name"

    # Run Crush CLI setup script
    echo "Setting up Crush CLI..."
    if ! docker exec "$container_name" /home/node/setup-crush.sh; then
        echo "Warning: Failed to setup Crush CLI"
    fi

    # Setup configuration and set CRUSH_GLOBAL_CONFIG
    echo "Setup Crush configuration..."
    docker exec "$container_name" /home/node/setup-crush-config.sh

    # Install pnpm if not already installed (uses npm cache)
    if ! docker exec "$container_name" sh -c "export PATH=/home/node/.npm-global/bin:\$PATH && command -v pnpm >/dev/null 2>&1"; then
        echo "Installing pnpm..."
        docker exec "$container_name" sh -c "npm config set prefix /home/node/.npm-global && npm install -g pnpm" >/dev/null 2>&1
        echo "pnpm installed"
    fi

    # Display npm version for verification
    local npm_version
    npm_version=$(docker exec "$container_name" npm --version 2>/dev/null || echo "not available")
    echo "npm version: $npm_version"

    # Display pnpm version if installed
    local pnpm_version
    pnpm_version=$(docker exec "$container_name" sh -c "export PATH=/home/node/.npm-global/bin:\$PATH && if command -v pnpm >/dev/null 2>&1; then pnpm --version; fi" 2>/dev/null || echo "")
    if [ -n "$pnpm_version" ]; then
        echo "pnpm version: $pnpm_version"
    fi

    # Configure pnpm cache directory and store location (if pnpm is installed)
    docker exec "$container_name" sh -c "export PATH=/home/node/.npm-global/bin:\$PATH && if command -v pnpm >/dev/null 2>&1; then pnpm config set cache-dir /workspace-cache/pnpm/cache && pnpm config set store-dir /workspace-cache/pnpm/store && echo 'pnpm store configured to:' && pnpm store path; else echo 'pnpm not installed'; fi"

    # Execute command in container
    # Build docker exec args
    local docker_exec_args=""

    # Add CRUSH_GLOBAL_CONFIG
    docker_exec_args="$docker_exec_args -e CRUSH_GLOBAL_CONFIG=/tmp/crush-config/merged"

    # Add PATH with npm global prefix so crush and pnpm can be found
    local container_path
    container_path=$(docker exec "$container_name" sh -c 'echo $PATH')
    docker_exec_args="$docker_exec_args -e PATH=/home/node/.npm-global/bin:$container_path"

    if [ "$shell_mode" = "true" ]; then
        # Execute an interactive shell in the container (for debugging)
        echo "Starting interactive shell in sandbox..."
        if [ -t 0 ]; then
            # Interactive mode with TTY
            docker exec -it $docker_exec_args "$container_name" /bin/sh
        else
            # Non-interactive mode (for testing)
            echo "Warning: Not running in TTY mode, starting shell anyway..."
            docker exec -i $docker_exec_args "$container_name" /bin/sh
        fi
    else
        # Execute Crush CLI
        echo "Starting Crush CLI..."
        if [ -t 0 ]; then
            # Interactive mode with TTY
            docker exec -it $docker_exec_args "$container_name" crush
        else
            # Non-interactive mode (for testing)
            echo "Warning: Not running in TTY mode, starting Crush CLI anyway..."
            docker exec -i $docker_exec_args "$container_name" crush
        fi
    fi

    # Stop the container after the session ends (but don't remove it)
    echo "Stopping container..."
    docker stop "$container_name" > /dev/null
    echo "Container stopped"
}

run_command() {
    # Validate Docker is available
    if ! validate_docker; then
        exit 1
    fi

    # Get workspace info
    local workspace
    workspace="$(get_workspace_info)"
    echo "Workspace: $workspace"

    # Validate workspace path for security (prevent command injection)
    validate_workspace_path "$workspace"

    # Scan workspace for credentials if enabled (before any container operations)
    scan_credentials "$workspace" "$CRED_SCAN"

    # Get container name
    local container_name
    container_name="$(get_container_name "$workspace")"
    echo "Container name: $container_name"

    # Get cache volume name
    local cache_volume_name
    cache_volume_name="$(get_cache_volume_name "$workspace")"
    echo "Cache volume: $cache_volume_name"

    # Create cache volume if it doesn't exist
    create_cache_volume "$cache_volume_name"

    # Read Git config
    local git_config
    git_config="$(read_git_config)"
    local git_name="${git_config%|*}"
    local git_email="${git_config##*|}"

    if [ -n "$git_name" ]; then
        echo "Git user.name: $git_name"
    fi
    if [ -n "$git_email" ]; then
        echo "Git user.email: $git_email"
    fi

    # Get host Crush config path
    local host_config_path=""
    if [ "$NO_HOST_CONFIG" = "true" ]; then
        echo "Skipping host Crush config (--no-host-config)"
    elif [ -n "$CUSTOM_CONFIG_PATH" ]; then
        # Use custom config path
        if [ -d "$CUSTOM_CONFIG_PATH" ]; then
            if [ -r "$CUSTOM_CONFIG_PATH" ]; then
                host_config_path="$CUSTOM_CONFIG_PATH"
                echo "Using custom Crush config: $host_config_path"
            else
                echo "Error: Custom config directory exists but is not readable: $CUSTOM_CONFIG_PATH" >&2
                exit 1
            fi
        else
            echo "Warning: Custom config directory not found: $CUSTOM_CONFIG_PATH" >&2
        fi
    else
        host_config_path="$(get_host_crush_config_path)"
        if [ -n "$host_config_path" ]; then
            echo "Host Crush config: $host_config_path"
        fi
    fi

    # Check if container exists, create if not
    if container_exists "$container_name"; then
        echo "Reusing existing container"
    else
        echo "Creating new container"
        create_container "$workspace" "$container_name" "$git_name" "$git_email" "$cache_volume_name" "$host_config_path"
    fi

    # Run the container
    run_container "$container_name" "$SHELL_MODE" "$host_config_path"
}

clean_command() {
    local force="$1"

    # Validate Docker is available
    if ! validate_docker; then
        exit 1
    fi

    # Get workspace info
    local workspace
    workspace="$(get_workspace_info)"

    # Get container name
    local container_name
    container_name="$(get_container_name "$workspace")"

    # Get cache volume name
    local cache_volume_name
    cache_volume_name="$(get_cache_volume_name "$workspace")"

    # Check if container exists
    if ! container_exists "$container_name"; then
        echo "No sandbox container found for workspace: $workspace"
    else
        echo "Found container: $container_name"

        # Confirm deletion unless --force flag is set
        if [ "$force" != "true" ]; then
            read -p "Are you sure you want to remove the container '$container_name'? [y/N] " confirm
            if [[ ! "$confirm" =~ ^[yY] ]]; then
                echo "Aborted"
                exit 0
            fi
        fi

        # Stop the container if it's running
        echo "Stopping container..."
        docker stop "$container_name" > /dev/null 2>&1 || true

        # Remove the container
        echo "Removing container..."
        docker rm "$container_name" > /dev/null 2>&1 || true

        echo "Container removed: $container_name"
    fi

    # Remove cache volume
    echo "Removing cache volume..."
    if docker volume rm "$cache_volume_name" > /dev/null 2>&1; then
        echo "Cache volume removed: $cache_volume_name"
    else
        echo "Cache volume not found: $cache_volume_name"
    fi
}

install_command() {
    # Validate Docker is available before installing
    if ! validate_docker; then
        echo "Error: Docker is required to use crush-sandbox" >&2
        echo "Please install Docker Desktop and ensure it is running" >&2
        exit 1
    fi

    local install_path="/usr/local/bin/crush-sandbox"
    local alias_path="/usr/local/bin/crushbox"
    local remote_url="https://raw.githubusercontent.com/wireless25/crush-sandbox/main/docker-sandbox-crush"

    # Check if already installed
    if [ -f "$install_path" ]; then
        echo "crush-sandbox is already installed at $install_path"
        read -p "Do you want to overwrite it? [y/N] " confirm
        if [[ ! "$confirm" =~ ^[yY] ]]; then
            echo "Installation cancelled"
            exit 0
        fi
    fi

    # Check if we can write to /usr/local/bin
    if [ ! -w "$(dirname "$install_path")" ]; then
        echo "Error: Cannot write to $(dirname "$install_path"). Please run with sudo or choose a different location." >&2
        exit 1
    fi

    # Download the script
    echo "Downloading crush-sandbox from GitHub..."
    if ! curl -fsSL "$remote_url" -o "$install_path"; then
        echo "Error: Failed to download script from $remote_url" >&2
        exit 1
    fi

    # Make executable
    chmod +x "$install_path"

    # Create alias symlink
    echo "Creating alias 'crushbox'..."
    if [ -L "$alias_path" ] || [ -f "$alias_path" ]; then
        echo "Removing existing $alias_path..."
        rm -f "$alias_path"
    fi
    ln -s "$install_path" "$alias_path"
    chmod +x "$alias_path"

    echo ""
    echo "✓ Successfully installed crush-sandbox to $install_path"
    echo "✓ Alias 'crushbox' created at $alias_path"
    echo "✓ Docker validated: $(docker --version)"
    echo ""
    echo "Note: gitleaks Docker image will be pulled on first use for credential scanning"
    echo ""
    echo "You can now run:"
    echo "  crush-sandbox run      # Start Crush CLI in sandbox"
    echo "  crushbox run           # Alias: same as crush-sandbox run"
    echo "  crush-sandbox clean    # Remove sandbox for current workspace"
    echo "  crush-sandbox update   # Update to latest version"
    echo ""
    echo "For more information, run:"
    echo "  crush-sandbox --help"
}

update_command() {
    local script_path="${BASH_SOURCE[0]}"
    local remote_url="https://raw.githubusercontent.com/wireless25/crush-sandbox/main/docker-sandbox-crush"
    local temp_file

    # Use mktemp for secure temporary file creation (TOCTOU race condition prevention)
    temp_file=$(mktemp) || {
        echo "Error: Failed to create temporary file" >&2
        exit 1
    }

    echo "Checking for updates..."

    # Download latest version to temp file
    echo "Downloading latest version from GitHub..."
    if ! curl -fsSL "$remote_url" -o "$temp_file"; then
        echo "Error: Failed to download latest version from $remote_url" >&2
        rm -f "$temp_file"
        exit 1
    fi

    # Make executable so we can validate it
    chmod +x "$temp_file"

    # Extract version from downloaded file using grep and cut
    local remote_version
    remote_version=$(grep '^VERSION=' "$temp_file" | head -1 | cut -d'"' -f2)
    if [ -z "$remote_version" ]; then
        echo "Error: Failed to determine remote version" >&2
        rm -f "$temp_file"
        exit 1
    fi

    echo "Current version: $VERSION"
    echo "Latest version:  $remote_version"

    # Check if already up to date
    if [ "$remote_version" = "$VERSION" ]; then
        echo ""
        echo "✓ You already have the latest version!"
        rm -f "$temp_file"
        exit 0
    fi

    # Confirm update
    echo ""
    read -p "Update to version $remote_version? [y/N] " confirm
    if [[ ! "$confirm" =~ ^[yY] ]]; then
        echo "Update cancelled"
        rm -f "$temp_file"
        exit 0
    fi

    # Validate that the downloaded script is valid bash
    if ! bash -n "$temp_file"; then
        echo "Error: Downloaded script has syntax errors, not updating" >&2
        rm -f "$temp_file"
        exit 1
    fi

    # Replace current script with updated version
    echo ""
    echo "Updating crush-sandbox..."
    if ! mv "$temp_file" "$script_path"; then
        echo "Error: Failed to update script. Try running with sudo." >&2
        rm -f "$temp_file"
        exit 1
    fi

    # Make executable
    chmod +x "$script_path"

    echo ""
    echo "✓ Successfully updated from $VERSION to $remote_version"
    echo "  Script location: $script_path"
    echo ""
    echo "Changes since your version:"
    echo "View release notes: https://github.com/wireless25/crush-sandbox/releases"
}

# Main script logic
if [ $# -lt 1 ]; then
    print_usage >&2
    exit 1
fi

# Parse arguments
COMMAND=""
FORCE="false"
SHELL_MODE="false"
SHOW_VERSION="false"
NO_HOST_CONFIG="false"
CRED_SCAN="false"

while [[ $# -gt 0 ]]; do
    case "$1" in
        --version)
            SHOW_VERSION="true"
            shift
            ;;
        --force)
            FORCE="true"
            shift
            ;;
        --shell)
            SHELL_MODE="true"
            shift
            ;;
        --no-host-config)
            NO_HOST_CONFIG="true"
            shift
            ;;
        --cred-scan)
            CRED_SCAN="true"
            shift
            ;;
        -*)
            echo "Error: Unknown option: $1" >&2
            print_usage
            exit 1
            ;;
        *)
            if [ -z "$COMMAND" ]; then
                COMMAND="$1"
            else
                echo "Error: Unexpected argument: $1" >&2
                print_usage
                exit 1
            fi
            shift
            ;;
    esac
done

# Show version and exit if requested
if [ "$SHOW_VERSION" = "true" ]; then
    echo "crush-sandbox version $VERSION"
    exit 0
fi

if [ -z "$COMMAND" ]; then
    print_usage >&2
    exit 1
fi

case "$COMMAND" in
    run)
        run_command
        ;;
    clean|reset)
        clean_command "$FORCE"
        ;;
    install)
        install_command
        ;;
    update)
        update_command
        ;;
    *)
        echo "Error: Unknown command: $COMMAND" >&2
        print_usage >&2
        exit 1
        ;;
esac
