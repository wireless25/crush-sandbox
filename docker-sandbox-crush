#!/bin/bash

set -e

VERSION="0.3.0"

print_usage() {
    echo "Usage: docker-sandbox-crush <command> [options]"
    echo ""
    echo "Commands:"
    echo "  run     Run Crush CLI in Docker sandbox"
    echo "  clean   Remove the sandbox container for current workspace"
    echo "  install Install this script to /usr/local/bin"
    echo "  update  Update to the latest version"
    echo ""
    echo "Options:"
    echo "  --version          Show version information"
    echo "  --force            Skip confirmation for clean command"
    echo "  --shell            Start interactive shell instead of Crush CLI (for debugging)"
    echo "  --no-host-config    Skip mounting host Crush config directory"
}

validate_docker() {
    # Check if Docker CLI is installed
    if ! command -v docker &> /dev/null; then
        echo "Error: docker CLI is not installed or not in PATH" >&2
        return 1
    fi

    # Check if Docker daemon is running and accessible
    if ! docker info &> /dev/null; then
        echo "Error: docker daemon is not running or not accessible" >&2
        return 1
    fi

    return 0
}

get_workspace_info() {
    local workspace
    workspace="$(pwd)"
    echo "$workspace"
}

read_git_config() {
    local gitconfig="$HOME/.gitconfig"
    local user_name=""
    local user_email=""

    if [ -f "$gitconfig" ]; then
        user_name="$(git config --file "$gitconfig" user.name 2>/dev/null || echo "")"
        user_email="$(git config --file "$gitconfig" user.email 2>/dev/null || echo "")"
    else
        echo "Warning: ~/.gitconfig not found" >&2
    fi

    if [ -z "$user_name" ] && [ -z "$user_email" ]; then
        echo "Warning: Git user.name and user.email not configured" >&2
    fi

    echo "$user_name|$user_email"
}

get_host_crush_config_path() {
    local config_path=""

    # Check ~/.config/crush/ first
    local config_dir_1="$HOME/.config/crush"
    if [ -d "$config_dir_1" ]; then
        if [ -r "$config_dir_1" ]; then
            config_path="$config_dir_1"
        else
            echo "Error: Crush config directory exists but is not readable: $config_dir_1" >&2
            exit 1
        fi
    fi

    # Log warning if no config directory found (but continue execution)
    if [ -z "$config_path" ]; then
        echo "Warning: No host Crush config directory found (checked ~/.config/crush/)" >&2
    fi

    echo "$config_path"
}

get_container_name() {
    local workspace="$1"
    # Use md5 hash of workspace path for deterministic container name
    # Prefix with 'crush-sandbox-' for readability
    local hash
    hash="$(echo -n "$workspace" | md5)"
    echo "crush-sandbox-${hash}"
}

get_cache_volume_name() {
    local workspace="$1"
    # Use md5 hash of workspace path for deterministic volume name
    # Prefix with 'crush-cache-' for readability
    local hash
    hash="$(echo -n "$workspace" | md5)"
    echo "crush-cache-${hash}"
}

container_exists() {
    local container_name="$1"
    # Use docker ps -a to check if container exists (including stopped containers)
    # --filter name=... matches containers with the exact name
    docker ps -a --filter "name=^${container_name}$" --format '{{.Names}}' | grep -q "^${container_name}$"
    return $?
}

create_cache_volume() {
    local cache_volume_name="$1"

    # Check if volume already exists
    if docker volume ls -q --filter "name=^${cache_volume_name}$" | grep -q "^${cache_volume_name}$"; then
        echo "Using existing cache volume: $cache_volume_name"
        return 0
    fi

    # Create the volume
    echo "Creating cache volume: $cache_volume_name"
    docker volume create "$cache_volume_name" > /dev/null
    echo "Cache volume created: $cache_volume_name"
}

create_container() {
    local workspace="$1"
    local container_name="$2"
    local git_name="$3"
    local git_email="$4"
    local cache_volume_name="$5"
    local host_config_path="$6"

    local base_image="node:18-alpine"
    local docker_args=(
        "--name" "$container_name"
        "-v" "${workspace}:${workspace}"
        "-v" "${cache_volume_name}:/workspace-cache"
        "-w" "$workspace"
        "--memory=4g"
        "--memory-swap=4g"
        "--cpus=2.0"
        "--ulimit" "nproc=100"
    )

    # Mount host Crush config read-only if available
    if [ -n "$host_config_path" ]; then
        docker_args+=("-v" "${host_config_path}:/host-crush-config:ro")
    fi

    # Configure npm cache to use persistent volume
    docker_args+=("-e" "npm_config_cache=/workspace-cache/npm")

    # Configure pnpm cache to use persistent volume
    # pnpm reads NPM_CONFIG_STORE for store directory
    docker_args+=("-e" "NPM_CONFIG_STORE=/workspace-cache/pnpm/store")
    docker_args+=("-e" "npm_config_store=/workspace-cache/pnpm/store")

    # Add environment variables for Git config if available
    if [ -n "$git_name" ]; then
        docker_args+=("-e" "GIT_USER_NAME=${git_name}")
    fi
    if [ -n "$git_email" ]; then
        docker_args+=("-e" "GIT_USER_EMAIL=${git_email}")
    fi

    docker_args+=("$base_image")
    # Use tail -f /dev/null to keep container running
    docker_args+=("tail" "-f" "/dev/null")

    echo "Creating container from image: ${base_image}"
    docker create "${docker_args[@]}"
}

setup_crush_script() {
    local container_name="$1"

    # Create the setup script inside the container
    docker exec "$container_name" sh -c 'cat > /usr/local/bin/setup-crush.sh << '\''EOF'\''
#!/bin/sh

# Check if Crush CLI is already installed
if command -v crush &> /dev/null; then
    exit 0
fi

# Install Crush CLI via npm global install
echo "Installing Crush CLI..."
if npm install -g @charmland/crush > /dev/null 2>&1; then
    echo "Crush CLI installed successfully"
    exit 0
else
    echo "Error: Failed to install Crush CLI"
    exit 1
fi
EOF
' > /dev/null 2>&1

    # Make the script executable
    docker exec "$container_name" chmod +x /usr/local/bin/setup-crush.sh > /dev/null 2>&1
}

setup_crush_config_script() {
    local container_name="$1"

    # Create the config merge script inside the container
    docker exec "$container_name" sh -c 'cat > /usr/local/bin/setup-crush-config.sh << '\''EOF'\''
#!/bin/sh

# Create merged config directory
mkdir -p /tmp/crush-config/merged

# Copy host config if available
if [ -d /host-crush-config ]; then
    cp -r /host-crush-config/* /tmp/crush-config/merged/ 2>/dev/null || true
    echo "Merged host configuration from /host-crush-config"
fi

# Set CRUSH_GLOBAL_CONFIG environment variable
export CRUSH_GLOBAL_CONFIG=/tmp/crush-config/merged
echo "Configuration merged to: \$CRUSH_GLOBAL_CONFIG"
EOF
' > /dev/null 2>&1

    # Make the script executable
    docker exec "$container_name" chmod +x /usr/local/bin/setup-crush-config.sh > /dev/null 2>&1
}

run_container() {
    local container_name="$1"
    local shell_mode="$2"
    local host_config_path="$3"

    # Start the container (or restart if it was stopped)
    echo "Starting container..."
    docker start "$container_name" > /dev/null

    # Setup Crush CLI script
    setup_crush_script "$container_name"
    setup_crush_config_script "$container_name"

    # Run Crush CLI setup script
    echo "Setting up Crush CLI..."
    if ! docker exec "$container_name" /usr/local/bin/setup-crush.sh; then
        echo "Warning: Failed to setup Crush CLI"
    fi

    # Setup configuration and set CRUSH_GLOBAL_CONFIG
    echo "Setup Crush configuration..."
    docker exec "$container_name" /usr/local/bin/setup-crush-config.sh

    # Install pnpm if not already installed (uses npm cache)
    if ! docker exec "$container_name" sh -c "command -v pnpm &> /dev/null"; then
        echo "Installing pnpm..."
        docker exec "$container_name" npm install -g pnpm > /dev/null 2>&1
        echo "pnpm installed"
    fi

    # Display npm version for verification
    local npm_version
    npm_version=$(docker exec "$container_name" npm --version 2>/dev/null || echo "not available")
    echo "npm version: $npm_version"

    # Display pnpm version if installed
    local pnpm_version
    pnpm_version=$(docker exec "$container_name" sh -c "if command -v pnpm &> /dev/null; then pnpm --version; fi" 2>/dev/null || echo "")
    if [ -n "$pnpm_version" ]; then
        echo "pnpm version: $pnpm_version"
    fi

    # Configure pnpm cache directory (if pnpm is installed)
    docker exec "$container_name" sh -c "if command -v pnpm &> /dev/null; then pnpm config set cache-dir /workspace-cache/pnpm/cache 2>/dev/null || true; fi" > /dev/null 2>&1

    # Execute command in container
    # Build docker exec args
    local docker_exec_args=""

    # Add CRUSH_GLOBAL_CONFIG
    docker_exec_args="$docker_exec_args -e CRUSH_GLOBAL_CONFIG=/tmp/crush-config/merged"

    if [ "$shell_mode" = "true" ]; then
        # Execute an interactive shell in the container (for debugging)
        echo "Starting interactive shell in sandbox..."
        if [ -t 0 ]; then
            # Interactive mode with TTY
            docker exec -it $docker_exec_args "$container_name" /bin/sh
        else
            # Non-interactive mode (for testing)
            echo "Warning: Not running in TTY mode, starting shell anyway..."
            docker exec -i $docker_exec_args "$container_name" /bin/sh
        fi
    else
        # Execute Crush CLI
        echo "Starting Crush CLI..."
        if [ -t 0 ]; then
            # Interactive mode with TTY
            docker exec -it $docker_exec_args "$container_name" crush
        else
            # Non-interactive mode (for testing)
            echo "Warning: Not running in TTY mode, starting Crush CLI anyway..."
            docker exec -i $docker_exec_args "$container_name" crush
        fi
    fi

    # Stop the container after the session ends (but don't remove it)
    echo "Stopping container..."
    docker stop "$container_name" > /dev/null
    echo "Container stopped"
}

run_command() {
    # Validate Docker is available
    if ! validate_docker; then
        exit 1
    fi

    # Get workspace info
    local workspace
    workspace="$(get_workspace_info)"
    echo "Workspace: $workspace"

    # Get container name
    local container_name
    container_name="$(get_container_name "$workspace")"
    echo "Container name: $container_name"

    # Get cache volume name
    local cache_volume_name
    cache_volume_name="$(get_cache_volume_name "$workspace")"
    echo "Cache volume: $cache_volume_name"

    # Create cache volume if it doesn't exist
    create_cache_volume "$cache_volume_name"

    # Read Git config
    local git_config
    git_config="$(read_git_config)"
    local git_name="${git_config%|*}"
    local git_email="${git_config##*|}"

    if [ -n "$git_name" ]; then
        echo "Git user.name: $git_name"
    fi
    if [ -n "$git_email" ]; then
        echo "Git user.email: $git_email"
    fi

    # Get host Crush config path
    local host_config_path=""
    if [ "$NO_HOST_CONFIG" = "true" ]; then
        echo "Skipping host Crush config (--no-host-config)"
    elif [ -n "$CUSTOM_CONFIG_PATH" ]; then
        # Use custom config path
        if [ -d "$CUSTOM_CONFIG_PATH" ]; then
            if [ -r "$CUSTOM_CONFIG_PATH" ]; then
                host_config_path="$CUSTOM_CONFIG_PATH"
                echo "Using custom Crush config: $host_config_path"
            else
                echo "Error: Custom config directory exists but is not readable: $CUSTOM_CONFIG_PATH" >&2
                exit 1
            fi
        else
            echo "Warning: Custom config directory not found: $CUSTOM_CONFIG_PATH" >&2
        fi
    else
        host_config_path="$(get_host_crush_config_path)"
        if [ -n "$host_config_path" ]; then
            echo "Host Crush config: $host_config_path"
        fi
    fi

    # Check if container exists, create if not
    if container_exists "$container_name"; then
        echo "Reusing existing container"
    else
        echo "Creating new container"
        create_container "$workspace" "$container_name" "$git_name" "$git_email" "$cache_volume_name" "$host_config_path"
    fi

    # Run the container
    run_container "$container_name" "$SHELL_MODE" "$host_config_path"
}

clean_command() {
    local force="$1"

    # Validate Docker is available
    if ! validate_docker; then
        exit 1
    fi

    # Get workspace info
    local workspace
    workspace="$(get_workspace_info)"

    # Get container name
    local container_name
    container_name="$(get_container_name "$workspace")"

    # Get cache volume name
    local cache_volume_name
    cache_volume_name="$(get_cache_volume_name "$workspace")"

    # Check if container exists
    if ! container_exists "$container_name"; then
        echo "No sandbox container found for workspace: $workspace"
    else
        echo "Found container: $container_name"

        # Confirm deletion unless --force flag is set
        if [ "$force" != "true" ]; then
            read -p "Are you sure you want to remove the container '$container_name'? [y/N] " confirm
            if [[ ! "$confirm" =~ ^[yY] ]]; then
                echo "Aborted"
                exit 0
            fi
        fi

        # Stop the container if it's running
        echo "Stopping container..."
        docker stop "$container_name" > /dev/null 2>&1 || true

        # Remove the container
        echo "Removing container..."
        docker rm "$container_name" > /dev/null 2>&1 || true

        echo "Container removed: $container_name"
    fi

    # Remove cache volume
    echo "Removing cache volume..."
    if docker volume rm "$cache_volume_name" > /dev/null 2>&1; then
        echo "Cache volume removed: $cache_volume_name"
    else
        echo "Cache volume not found: $cache_volume_name"
    fi
}

install_command() {
    # Validate Docker is available before installing
    if ! validate_docker; then
        echo "Error: Docker is required to use docker-sandbox-crush" >&2
        echo "Please install Docker Desktop and ensure it is running" >&2
        exit 1
    fi

    local install_path="/usr/local/bin/docker-sandbox-crush"
    local remote_url="https://raw.githubusercontent.com/wireless25/crush-sandbox/main/docker-sandbox-crush"

    # Check if already installed
    if [ -f "$install_path" ]; then
        echo "docker-sandbox-crush is already installed at $install_path"
        read -p "Do you want to overwrite it? [y/N] " confirm
        if [[ ! "$confirm" =~ ^[yY] ]]; then
            echo "Installation cancelled"
            exit 0
        fi
    fi

    # Check if we can write to /usr/local/bin
    if [ ! -w "$(dirname "$install_path")" ]; then
        echo "Error: Cannot write to $(dirname "$install_path"). Please run with sudo or choose a different location." >&2
        exit 1
    fi

    # Download the script
    echo "Downloading docker-sandbox-crush from GitHub..."
    if ! curl -fsSL "$remote_url" -o "$install_path"; then
        echo "Error: Failed to download script from $remote_url" >&2
        exit 1
    fi

    # Make executable
    chmod +x "$install_path"

    echo "✓ Successfully installed docker-sandbox-crush to $install_path"
    echo "✓ Docker validated: $(docker --version)"
    echo ""
    echo "You can now run:"
    echo "  docker-sandbox-crush run      # Start Crush CLI in sandbox"
    echo "  docker-sandbox-crush clean    # Remove sandbox for current workspace"
    echo "  docker-sandbox-crush update   # Update to latest version"
    echo ""
    echo "For more information, run:"
    echo "  docker-sandbox-crush --help"
}

update_command() {
    local script_path="${BASH_SOURCE[0]}"
    local remote_url="https://raw.githubusercontent.com/wireless25/crush-sandbox/main/docker-sandbox-crush"
    local temp_file="/tmp/docker-sandbox-crush-update.$$"

    echo "Checking for updates..."

    # Download latest version to temp file
    echo "Downloading latest version from GitHub..."
    if ! curl -fsSL "$remote_url" -o "$temp_file"; then
        echo "Error: Failed to download latest version from $remote_url" >&2
        rm -f "$temp_file"
        exit 1
    fi

    # Make executable so we can validate it
    chmod +x "$temp_file"

    # Extract version from downloaded file using grep and cut
    local remote_version
    remote_version=$(grep '^VERSION=' "$temp_file" | head -1 | cut -d'"' -f2)
    if [ -z "$remote_version" ]; then
        echo "Error: Failed to determine remote version" >&2
        rm -f "$temp_file"
        exit 1
    fi

    echo "Current version: $VERSION"
    echo "Latest version:  $remote_version"

    # Check if already up to date
    if [ "$remote_version" = "$VERSION" ]; then
        echo ""
        echo "✓ You already have the latest version!"
        rm -f "$temp_file"
        exit 0
    fi

    # Confirm update
    echo ""
    read -p "Update to version $remote_version? [y/N] " confirm
    if [[ ! "$confirm" =~ ^[yY] ]]; then
        echo "Update cancelled"
        rm -f "$temp_file"
        exit 0
    fi

    # Validate that the downloaded script is valid bash
    if ! bash -n "$temp_file"; then
        echo "Error: Downloaded script has syntax errors, not updating" >&2
        rm -f "$temp_file"
        exit 1
    fi

    # Replace current script with updated version
    echo ""
    echo "Updating docker-sandbox-crush..."
    if ! mv "$temp_file" "$script_path"; then
        echo "Error: Failed to update script. Try running with sudo." >&2
        rm -f "$temp_file"
        exit 1
    fi

    # Make executable
    chmod +x "$script_path"

    echo ""
    echo "✓ Successfully updated from $VERSION to $remote_version"
    echo "  Script location: $script_path"
    echo ""
    echo "Changes since your version:"
    echo "  View release notes: https://github.com/wireless25/crush-sandbox/releases"
}

# Main script logic
if [ $# -lt 1 ]; then
    print_usage >&2
    exit 1
fi

# Parse arguments
COMMAND=""
FORCE="false"
SHELL_MODE="false"
SHOW_VERSION="false"
NO_HOST_CONFIG="false"

while [[ $# -gt 0 ]]; do
    case "$1" in
        --version)
            SHOW_VERSION="true"
            shift
            ;;
        --force)
            FORCE="true"
            shift
            ;;
        --shell)
            SHELL_MODE="true"
            shift
            ;;
        --no-host-config)
            NO_HOST_CONFIG="true"
            shift
            ;;
        -*)
            echo "Error: Unknown option: $1" >&2
            print_usage
            exit 1
            ;;
        *)
            if [ -z "$COMMAND" ]; then
                COMMAND="$1"
            else
                echo "Error: Unexpected argument: $1" >&2
                print_usage
                exit 1
            fi
            shift
            ;;
    esac
done

# Show version and exit if requested
if [ "$SHOW_VERSION" = "true" ]; then
    echo "docker-sandbox-crush version $VERSION"
    exit 0
fi

if [ -z "$COMMAND" ]; then
    print_usage >&2
    exit 1
fi

case "$COMMAND" in
    run)
        run_command
        ;;
    clean|reset)
        clean_command "$FORCE"
        ;;
    install)
        install_command
        ;;
    update)
        update_command
        ;;
    *)
        echo "Error: Unknown command: $COMMAND" >&2
        print_usage >&2
        exit 1
        ;;
esac
